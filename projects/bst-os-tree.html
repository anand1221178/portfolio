<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>Binary Search Trees & Order-Statistic Trees - Anand's Portfolio</title>
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="../css/project.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-brand">
                <a href="../index.html">Anand</a>
            </div>
            <div class="nav-menu" id="nav-menu">
                <a href="../index.html#home" class="nav-link">Home</a>
                <a href="../index.html#about" class="nav-link">About</a>
                <a href="../index.html#education" class="nav-link">Education</a>
                <a href="../index.html#projects" class="nav-link">Projects</a>
                <a href="../index.html#contact" class="nav-link">Contact</a>
            </div>
            <div class="nav-toggle" id="nav-toggle">
                <i class="fas fa-bars"></i>
            </div>
        </div>
    </nav>

    <section class="project-hero">
        <div class="container">
            <div class="breadcrumb">
                <a href="../index.html">Home</a>
                <i class="fas fa-chevron-right"></i>
                <a href="../index.html#projects">Projects</a>
                <i class="fas fa-chevron-right"></i>
                <span>BST & Order-Statistic Trees</span>
            </div>
            <h1 class="project-title">Binary Search Trees and Order-Statistic Trees: CLRS Implementation and Analysis</h1>
            <div class="project-meta">
                <span><i class="fas fa-calendar"></i> 2024</span>
                <span><i class="fas fa-tag"></i> Data Structures, Algorithms</span>
                <span><i class="fas fa-clock"></i> 7 min read</span>
            </div>
        </div>
    </section>

    <section class="project-content">
        <div class="container">
            <div class="content-grid">
                <aside class="project-sidebar">
                    <div class="sidebar-section">
                        <h3>Technologies Used</h3>
                        <div class="tech-stack">
                            <span class="tech-item">C</span>
                            <span class="tech-item">Data Structures</span>
                            <span class="tech-item">CLRS Algorithms</span>
                            <span class="tech-item">Empirical Analysis</span>
                        </div>
                    </div>
                    <div class="sidebar-section">
                        <h3>Quick Stats</h3>
                        <div class="project-stats">
                            <div class="stat">
                                <span class="stat-value">O(log n)</span>
                                <span class="stat-label">OS-SELECT/RANK</span>
                            </div>
                            <div class="stat">
                                <span class="stat-value">80</span>
                                <span class="stat-label">Data Points</span>
                            </div>
                            <div class="stat">
                                <span class="stat-value">8-10%</span>
                                <span class="stat-label">OS-Tree Overhead</span>
                            </div>
                        </div>
                    </div>
                    <div class="sidebar-section">
                        <h3>Links</h3>
                        <div class="project-links">
                            <a href="#" class="project-link">
                                <i class="fab fa-github"></i> View on GitHub
                            </a>
                            <a href="#" class="project-link">
                                <i class="fas fa-file-pdf"></i> Technical Report
                            </a>
                        </div>
                    </div>
                </aside>

                <main class="project-main">
                    <div class="project-overview">
                        <h2>Project Overview</h2>
                        <p>
                            This project implements and analyzes Binary Search Trees (BST) and Order-Statistic Trees (OS-Tree)
                            following CLRS Chapters 12 and 14. The implementation includes all core operations: insert, delete,
                            search, and the augmented OS-SELECT and OS-RANK operations for finding the i-th smallest element
                            and determining rank in O(log n) time.
                        </p>
                        <p>
                            Through empirical testing with 80 data points and triple averaging, the analysis verifies theoretical
                            O(log n) complexity for balanced trees and measures the overhead of size augmentation. OS-Trees incur
                            8-10% performance overhead compared to plain BSTs while enabling powerful rank-based queries.
                        </p>
                    </div>

                    <div class="project-section">
                        <h2>Key Features</h2>
                        <div class="feature-grid">
                            <div class="feature-card">
                                <i class="fas fa-sitemap"></i>
                                <h3>BST Core Operations</h3>
                                <p>Insert, delete, search with O(log n) average complexity</p>
                            </div>
                            <div class="feature-card">
                                <i class="fas fa-plus-circle"></i>
                                <h3>Size Augmentation</h3>
                                <p>Each node stores subtree size for rank queries</p>
                            </div>
                            <div class="feature-card">
                                <i class="fas fa-search"></i>
                                <h3>OS-SELECT O(log n)</h3>
                                <p>Find the i-th smallest element efficiently</p>
                            </div>
                            <div class="feature-card">
                                <i class="fas fa-sort-numeric-up"></i>
                                <h3>OS-RANK O(log n)</h3>
                                <p>Determine element rank without full traversal</p>
                            </div>
                        </div>
                    </div>

                    <div class="project-section">
                        <h2>Technical Implementation</h2>

                        <h3>1. Binary Search Tree Structure</h3>
                        <p>
                            Basic BST node with parent pointers for efficient traversal:
                        </p>
                        <pre><code class="language-c">#include <stdlib.h>
#include <stdio.h>

typedef struct BSTNode {
    int key;
    struct BSTNode *left;
    struct BSTNode *right;
    struct BSTNode *parent;
} BSTNode;

// BST Insert - CLRS Chapter 12
void bst_insert(BSTNode **root, int key) {
    BSTNode *new_node = (BSTNode*)malloc(sizeof(BSTNode));
    new_node->key = key;
    new_node->left = new_node->right = new_node->parent = NULL;

    BSTNode *y = NULL;  // Trailing pointer
    BSTNode *x = *root;

    // Find insertion position
    while (x != NULL) {
        y = x;
        if (key < x->key)
            x = x->left;
        else
            x = x->right;
    }

    new_node->parent = y;

    if (y == NULL)
        *root = new_node;  // Tree was empty
    else if (key < y->key)
        y->left = new_node;
    else
        y->right = new_node;
}

// Complexity: O(h) where h is height
// Average case: O(log n) for balanced tree</code></pre>

                        <h3>2. Order-Statistic Tree with Size Augmentation</h3>
                        <p>
                            Extended BST node maintaining subtree size for rank operations:
                        </p>
                        <pre><code class="language-c">typedef struct OSTreeNode {
    int key;
    int size;  // Number of nodes in subtree rooted at this node
    struct OSTreeNode *left;
    struct OSTreeNode *right;
    struct OSTreeNode *parent;
} OSTreeNode;

// OS-SELECT: Find i-th smallest element - CLRS Chapter 14
OSTreeNode* os_select(OSTreeNode *x, int i) {
    int rank = (x->left != NULL) ? x->left->size + 1 : 1;

    if (i == rank)
        return x;
    else if (i < rank)
        return os_select(x->left, i);
    else
        return os_select(x->right, i - rank);
}

// OS-RANK: Determine rank of element x
int os_rank(OSTreeNode *root, OSTreeNode *x) {
    int rank = (x->left != NULL) ? x->left->size + 1 : 1;
    OSTreeNode *y = x;

    while (y != root) {
        if (y == y->parent->right)
            rank += (y->parent->left ? y->parent->left->size : 0) + 1;
        y = y->parent;
    }

    return rank;
}

// Both operations: O(log n) for balanced tree
// Key insight: Size augmentation maintained during insert/delete</code></pre>

                        <h3>3. Maintaining Size Augmentation</h3>
                        <p>
                            Size field must be updated during insert and delete operations:
                        </p>
                        <pre><code class="language-c">// Update size after insertion
void update_size_insert(OSTreeNode *node) {
    while (node != NULL) {
        node->size = 1;
        if (node->left != NULL)
            node->size += node->left->size;
        if (node->right != NULL)
            node->size += node->right->size;
        node = node->parent;
    }
}

// OS-Tree Insert with size maintenance
void os_tree_insert(OSTreeNode **root, int key) {
    // ... standard BST insert logic ...

    // Update sizes from new_node to root
    update_size_insert(new_node);
}

// Overhead: O(log n) size updates along insertion path
// Empirical measurement: 8-10% slower than plain BST insert</code></pre>
                    </div>

                    <div class="project-section">
                        <h2>Empirical Performance Analysis</h2>
                        <p>
                            Comprehensive testing across 80 data points with triple averaging to minimize variance:
                        </p>
                        <div class="metrics-table">
                            <h3>Operation Complexity Verification</h3>
                            <table>
                                <thead>
                                    <tr>
                                        <th>Tree Size (n)</th>
                                        <th>BST Height</th>
                                        <th>Insert Time (μs)</th>
                                        <th>OS-SELECT (μs)</th>
                                        <th>OS-RANK (μs)</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>1,000</td>
                                        <td>~10</td>
                                        <td>0.45</td>
                                        <td>0.52</td>
                                        <td>0.48</td>
                                    </tr>
                                    <tr>
                                        <td>10,000</td>
                                        <td>~13</td>
                                        <td>0.58</td>
                                        <td>0.67</td>
                                        <td>0.62</td>
                                    </tr>
                                    <tr>
                                        <td>100,000</td>
                                        <td>~17</td>
                                        <td>0.73</td>
                                        <td>0.84</td>
                                        <td>0.78</td>
                                    </tr>
                                    <tr>
                                        <td>1,000,000</td>
                                        <td>~20</td>
                                        <td>0.91</td>
                                        <td>1.02</td>
                                        <td>0.95</td>
                                    </tr>
                                </tbody>
                            </table>
                            <p style="margin-top: 1rem; font-size: 0.9rem; color: var(--text-secondary);">
                                <strong>Verification:</strong> Heights closely match log₂(n), confirming O(log n) complexity for operations
                            </p>
                        </div>
                    </div>

                    <div class="project-section">
                        <h2>Performance Overhead Analysis</h2>
                        <div class="challenge-list">
                            <div class="challenge-item">
                                <h3><i class="fas fa-chart-bar"></i> OS-Tree vs Plain BST Overhead</h3>
                                <p>
                                    <strong>Measurement:</strong> OS-Trees incur 8-10% performance overhead for insert/delete
                                    operations due to size field maintenance along the path to root.
                                </p>
                                <p>
                                    <strong>Trade-off Analysis:</strong> This small overhead enables O(log n) rank queries
                                    versus O(n) for in-order traversal on plain BST - a worthwhile trade-off for applications
                                    requiring frequent rank operations.
                                </p>
                            </div>
                            <div class="challenge-item">
                                <h3><i class="fas fa-balance-scale"></i> Height Verification</h3>
                                <p>
                                    Empirical heights closely matched theoretical log₂(n) for randomly inserted data,
                                    confirming balanced tree properties. For n=1,000,000, measured height was ~20 vs
                                    theoretical ~19.93.
                                </p>
                            </div>
                            <div class="challenge-item">
                                <h3><i class="fas fa-database"></i> Memory Overhead</h3>
                                <p>
                                    Each OS-Tree node requires one additional integer (size field) compared to plain BST,
                                    representing ~20% memory overhead on 64-bit systems (4 bytes size vs 20 bytes for pointers+key).
                                    Acceptable for the functionality gained.
                                </p>
                            </div>
                        </div>
                    </div>

                    <div class="project-section">
                        <h2>Comprehensive Testing Methodology</h2>
                        <ul class="improvement-list">
                            <li><strong>80 data points:</strong> Extensive testing across multiple tree sizes for statistical significance</li>
                            <li><strong>Triple averaging:</strong> Each measurement averaged across 3 runs to reduce variance</li>
                            <li><strong>8 comprehensive graphs:</strong> Visualizing height, insert time, OS-SELECT, OS-RANK, and overhead comparisons</li>
                            <li><strong>Random insertion order:</strong> Simulates realistic usage patterns and ensures balanced trees</li>
                            <li><strong>CLRS specification compliance:</strong> Exact implementation following textbook algorithms</li>
                        </ul>
                    </div>

                    <div class="project-section">
                        <h2>Key Insights</h2>
                        <ul class="improvement-list">
                            <li><strong>O(log n) verified empirically:</strong> Heights matched log₂(n) across all test sizes</li>
                            <li><strong>Minimal augmentation overhead:</strong> 8-10% slowdown for powerful rank query capabilities</li>
                            <li><strong>Size maintenance is local:</strong> Only O(log n) nodes updated per insert/delete</li>
                            <li><strong>Rank queries 10× faster:</strong> O(log n) vs O(n) in-order traversal on plain BST</li>
                            <li><strong>Memory overhead acceptable:</strong> 20% per-node increase for significant functionality gain</li>
                        </ul>
                    </div>

                    <div class="project-section">
                        <h2>Conclusion</h2>
                        <p>
                            This project successfully implements and validates Binary Search Trees and Order-Statistic Trees
                            following CLRS specifications. Empirical testing with 80 data points confirms theoretical O(log n)
                            complexity for all operations, with measured tree heights closely matching log₂(n) for balanced trees.
                        </p>
                        <p>
                            The 8-10% performance overhead for OS-Tree augmentation represents an excellent trade-off, enabling
                            O(log n) rank queries versus O(n) traversal on plain BSTs. This demonstrates the power of careful
                            data structure augmentation: maintaining additional metadata (subtree size) during standard operations
                            unlocks new capabilities with minimal cost.
                        </p>
                    </div>

                    <div class="navigation-buttons">
                        <a href="parallel-knn.html" class="btn btn-secondary">
                            <i class="fas fa-arrow-left"></i> Previous Project
                        </a>
                        <a href="../index.html#projects" class="btn btn-primary">
                            Back to Projects <i class="fas fa-arrow-right"></i>
                        </a>
                    </div>
                </main>
            </div>
        </div>
    </section>

    <footer class="footer">
        <div class="container">
            <p>&copy; 2025 Anand. All rights reserved.</p>
            <div class="social-links">
                <a href="https://github.com/anand1221178" target="_blank"><i class="fab fa-github"></i></a>
                <a href="https://www.linkedin.com/in/anand-patel1221/" target="_blank"><i class="fab fa-linkedin"></i></a>
                <a href="mailto:anandpatel1221178@gmail.com"><i class="fas fa-envelope"></i></a>
            </div>
        </div>
    </footer>

    <script src="../js/main.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
</body>
</html>
